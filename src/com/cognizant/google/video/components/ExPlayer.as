package com.cognizant.google.video.components {	import com.cognizant.google.video.data.PlayerSettings;	import com.cognizant.google.video.data.VideoData;	import com.cognizant.google.video.data.VideoEventData;	import com.cognizant.google.video.events.CustomVideoEvent;	import com.google.ads.studio.utils.StudioClassAccessor;	import flash.display.DisplayObject;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.TimerEvent;	import flash.utils.Timer;			/**	 * ...	 * 	 * @author Rafael Nepomuceno	 * 	 * @created mm/dd/yyyy 00:00 AM	 */	public class ExPlayer extends Sprite {				// NOTE: This should be the order of access modifiers per section.		// - PUBLIC		// - INTERNAL		// - PROTECTED		// - PRIVATE				// Please use these section dividers as the guide limit length of chars per line.		// ------------------------------- STATIC VARIABLES --------------------------------		private static var _collection:Array = []; // VideoPlayer on stage		private static var _handlers:Array = [];		private static var _currentVideo:ExPlayer;				// ----------------------------------- VARIABLES -----------------------------------		public var autoDestroy:Boolean;				private var _settings:PlayerSettings;		private var _handler:Function;		private var _hasAllStudioEventListeners:Boolean;		private var _autoPlay:Boolean;		private var _componentInstance:Object;		private var _currentIndex:int;		private var _timer:Timer;				private var _buffered:Boolean;		private var _bufferCallbacks:Array = [];		private var _buffredIndexes:Object = {};		private var _timers:Object = {};				private var _isDestroyed:Boolean;				// --------------=--------------- STATIC GETTERS/SETTERS ---------------------------				// --------------------------- OVERRIDEN GETTERS/SETTERS ---------------------------				// ------------------------------- GETTERS/SETTERS ---------------------------------		public function get settings ():PlayerSettings { return _settings; }		public function get id ():String { return _settings.id; }		public function get componentInstance ():Object { return _componentInstance }		public function get currentController ():Object { return _componentInstance.getCurrentVideoController(); }				// ------------------------------- STATIC METHODS ----------------------------------		public static function addAllEventListeners (handler:Function):void {			_handlers.push(handler);		}				public static function removeAllEventListeners ():void {			_handlers.length = 0;		}				public static function dispatchEvent (e:CustomVideoEvent):void {			var i:int = _handlers.length;			while (i--)				_handlers[i](e);		}				public static function getCurrentVideoController ():Object {			return getCurrentVideo().currentController;		}				public static function getCurrentVideo ():ExPlayer {			return _currentVideo;		}				public static function getVideo (id:String):ExPlayer {			for each (var vid:ExPlayer in _collection)				if (vid.id == id) return vid;			return null;		}				public static function pauseAll ():void {			for each (var vid:ExPlayer in _collection)				vid.pause();		}				public static function stopAll ():void {			for each (var vid:ExPlayer in _collection)				vid.stop();		}				public static function muteAll ():void {			for each (var vid:ExPlayer in _collection)				vid.mute();		}				public static function destroyAll ():void {			for each (var vid:ExPlayer in _collection)				vid.destroy();		}				// -------------------------------- CONSTRUCTOR ------------------------------------				public function ExPlayer () {			// constructor code			if (stage) addedToStageHandler(null);			else addEventListener(Event.ADDED_TO_STAGE, addedToStageHandler);		}								// ----------------------------- OVERRIDEN METHODS ---------------------------------		override public function dispatchEvent (e:Event):Boolean {			ExPlayer.dispatchEvent(CustomVideoEvent(e));			return super.dispatchEvent(e);		}				// ------------------------   OVERRIDEN EVENT HANDLERS -----------------------------				// ---------------------------------  METHODS --------------------------------------				public function init (settings:PlayerSettings):void {			autoDestroy = settings.autoDestroy;			_autoPlay = settings.autoPlay;						if (!settings.componentInstance) { // Create new component instance				var videoPlayerAdvanced:Class = StudioClassAccessor.getClass('com.google.ads.studio.video.VideoPlayerAdvanced');				_componentInstance = new videoPlayerAdvanced();							} else { // Use existing component instance				_componentInstance = settings.componentInstance;							}						if (settings.autoPlay) {				if (settings.previewTime > 0) {					_timer = new Timer(settings.previewTime * 1000, 1);					_timer.addEventListener(TimerEvent.TIMER_COMPLETE, function ():void {						pause();						dispatchEvent(new CustomVideoEvent(CustomVideoEvent.PREVIEW_COMPLETE, new VideoEventData(id, currentController.getReportingIdentifier(), getCurrentVideoIndex())));					});				}			}									var progressive:Array = settings.progressiveData || [];			var streaming:Array = settings.streamingData || [];			var playlist:Object = componentInstance.getPlaylist();						var vidData:VideoData;			var i:int;			var len:int = streaming.length >= progressive.length ? streaming.length : progressive.length;										if (!settings.componentInstance)			if (settings.dimension) {				componentInstance.x = settings.dimension.x;				componentInstance.y = settings.dimension.y;				componentInstance.width = settings.dimension.width;				componentInstance.height = settings.dimension.height;			}						componentInstance.videoSmoothing = true;			setAutoAdvanceVideoOnComplete(false);						if (settings.autoAdvanceVideoOnComplete) {				//playlist.setVideoCompleteCallback(function ():void {					//if (getCurrentVideoIndex() + 1 <= getNumberOfVideoControllers() -1)						//next();				//});			}						for (i = 0; i < len; i++) {				playlist.addVideoController(createVideoController(streaming[i], progressive[i]));			}						currentController.setVideoObject(componentInstance.getVideoObject());						componentInstance.startMuted = settings.startMuted;			if (settings.autoPlay) {				if (settings.startMuted) 					currentController.mute();				playlist.start(true);			}						if (!settings.componentInstance)				addChild(componentInstance as DisplayObject);			addAllStudioEventListeners();						componentInstance.addEventListener('buffered', function (e:Object):void {				trace('> ExPlayer::BUFFERED\t->\t[id="' + id + '" reportingIdentifier="' + currentController.getReportingIdentifier() + '" index=' + getCurrentVideoIndex() + ']' );				_buffredIndexes[getCurrentVideoIndex()] = true;								removeAllStudioEventListeners();				addAllStudioEventListeners();				callBufferedCallbacks();			});						_settings = settings;		}				public function setAutoAdvanceVideoOnComplete (value:Boolean):void {			// REMINDER: If this was set to true the "SKIP" event won't fire if it auto advance to next video.			componentInstance.getPlaylist().setAutoAdvanceVideoOnComplete(value);		}				public function getCurrentVideoIndex ():int {			return componentInstance.getPlaylist() ? componentInstance.getPlaylist().getCurrentVideoControllerIndex() : _currentIndex;		}				public function getNumberOfVideoControllers ():int {			return componentInstance.getPlaylist().getNumberOfVideoControllers();		}				public function play (fromInteraction:Boolean = false):void {			if (fromInteraction) {				cancelPreview();				dispatchEvent(new CustomVideoEvent(CustomVideoEvent.USER_PLAY, new VideoEventData(id, currentController.getReportingIdentifier(), getCurrentVideoIndex())));			}			callOnBuffered(componentInstance.play);		}				public function pause (fromInteraction:Boolean = false):void {			if (fromInteraction) {				cancelPreview();				dispatchEvent(new CustomVideoEvent(CustomVideoEvent.USER_PAUSE, new VideoEventData(id, currentController.getReportingIdentifier(), getCurrentVideoIndex())));			}			callOnBuffered(componentInstance.pause);		}				public function stop (fromInteraction:Boolean = false):void {			if (fromInteraction) {				cancelPreview();				dispatchEvent(new CustomVideoEvent(CustomVideoEvent.USER_STOP, new VideoEventData(id, currentController.getReportingIdentifier(), getCurrentVideoIndex())));			}			callOnBuffered(componentInstance.stop);		}				public function mute (fromInteraction:Boolean = false):void {			if (fromInteraction) {				cancelPreview();				dispatchEvent(new CustomVideoEvent(CustomVideoEvent.USER_MUTE, new VideoEventData(id, currentController.getReportingIdentifier(), getCurrentVideoIndex())));			}			callOnBuffered(componentInstance.mute);		}				public function unmute (fromInteraction:Boolean = false):void {			if (fromInteraction) {				cancelPreview();				dispatchEvent(new CustomVideoEvent(CustomVideoEvent.USER_UNMUTE, new VideoEventData(id, currentController.getReportingIdentifier(), getCurrentVideoIndex())));			}			callOnBuffered(componentInstance.unmute);		}				public function seek (sec:Number, fromInteraction:Boolean = false):void {			if (fromInteraction) {				cancelPreview();				dispatchEvent(new CustomVideoEvent(CustomVideoEvent.USER_SEEK, new VideoEventData(id, currentController.getReportingIdentifier(), getCurrentVideoIndex())));			}			callOnBuffered(function ():void {				componentInstance.seek(sec);				//_buffered = false;			});		}				public function skipTo (index:int):void {			cancelPreview();						var tmpIndex:int = getCurrentVideoIndex();			if (index == tmpIndex) return;						dispatchStopTimer(tmpIndex);						callOnBuffered(function ():void {				removeAllStudioEventListeners();				componentInstance.skipTo(index);				_currentIndex = index;								if (!_buffredIndexes[index])					_buffered = false;				else 					addAllStudioEventListeners();								dispatchEvent(new CustomVideoEvent(CustomVideoEvent.SKIP, new VideoEventData(id, currentController.getReportingIdentifier(), getCurrentVideoIndex())));			});		}				public function replay (fromInteraction:Boolean = false):void {			if (fromInteraction) {				cancelPreview();				dispatchEvent(new CustomVideoEvent(CustomVideoEvent.USER_REPLAY, new VideoEventData(id, currentController.getReportingIdentifier(), getCurrentVideoIndex())));			}			cancelPreview();			callOnBuffered(currentController.replay);		}				public function next ():void {			cancelPreview();						var index:int = getCurrentVideoIndex();			dispatchStopTimer(index);						callOnBuffered(function ():void {				var numVideos:int = getNumberOfVideoControllers() - 1;				var nextIndex:int = index + 1;				if (nextIndex >= numVideos)					nextIndex = 0;								removeAllStudioEventListeners();				componentInstance.next();				_currentIndex = nextIndex;								if (!_buffredIndexes[nextIndex])					_buffered = false;				else 					addAllStudioEventListeners();								dispatchEvent(new CustomVideoEvent(CustomVideoEvent.SKIP, new VideoEventData(id, currentController.getReportingIdentifier(), getCurrentVideoIndex())));							});		}				public function previous ():void {			cancelPreview();						var index:int = getCurrentVideoIndex();			dispatchStopTimer(index);						callOnBuffered(function ():void {				var numVideos:int = getNumberOfVideoControllers() - 1;				var prevIndex:int = index - 1;				if (prevIndex <= 0)					prevIndex = numVideos;									removeAllStudioEventListeners();				componentInstance.previous();				_currentIndex = prevIndex;								if (!_buffredIndexes[prevIndex])					_buffered = false;				else 					addAllStudioEventListeners();								dispatchEvent(new CustomVideoEvent(CustomVideoEvent.SKIP, new VideoEventData(id, currentController.getReportingIdentifier(), getCurrentVideoIndex())));			});		}				public function setVolume (value:Number):void {			currentController.setVolume(value);		}				public function getVolume ():Number {			return currentController.getVolume();		}				public function enterFullscreen ():void {			dispatchEvent(new CustomVideoEvent(CustomVideoEvent.ENTER_FULLSCREEN, new VideoEventData(id, currentController.getReportingIdentifier(), getCurrentVideoIndex())));		}				public function exitFullScreen ():void {			dispatchEvent(new CustomVideoEvent(CustomVideoEvent.EXIT_FULLSCREEN, new VideoEventData(id, currentController.getReportingIdentifier(), getCurrentVideoIndex())));		}				public function destroy ():void {			if (_isDestroyed) return;						_isDestroyed = true;			_bufferCallbacks.length = 0;			_buffredIndexes = {};			_timers = {};			removeAllStudioEventListeners();			componentInstance.unload();		}				public function cancelPreview ():void {			if (_timer) {				_timer.stop();				_timer = null;			}		}												private function createVideoController (streaming:VideoData, progressive:VideoData = null):Object {			var enhancedVideoController:Class = StudioClassAccessor.getClass('com.google.ads.studio.video.EnhancedVideoController');			var videoEntry:Class = StudioClassAccessor.getClass('com.google.ads.studio.video.VideoEntry');						var vidCtrl:Object = new enhancedVideoController();						var vidEntry:Object;						if (streaming) {				// streaming				vidCtrl.setReportingIdentifier(streaming.reportingIdentifier);				vidEntry = new videoEntry(streaming.low, streaming.medium, streaming.high, StudioClassAccessor.getClass('com.google.ads.studio.video.SmartStreamingConnection'));				vidCtrl.addVideoEntry(vidEntry);								// progressive fallback				if (progressive) {					vidEntry = new videoEntry(progressive.low, progressive.medium, progressive.high);					vidCtrl.addVideoEntry(vidEntry);				}			} else if (progressive) {				vidCtrl.setReportingIdentifier(progressive.reportingIdentifier);				vidEntry = new videoEntry(progressive.low, progressive.medium, progressive.high);				vidCtrl.addVideoEntry(vidEntry);			} else {				throw new Error('VideoPlayer:: No VideoData found.');			}						vidCtrl.setVideoCompleteDisplay('videoCompleteShowLastFrame');						return vidCtrl;		}				private function dispatchStartTimer (index:int):void {			if (!_timers[index]) {				_timers[index] = true;								dispatchEvent(new CustomVideoEvent(CustomVideoEvent.VIDEO_VIEW_TIMER_START, new VideoEventData(id, currentController.getReportingIdentifier(), index)));			}		}				private function dispatchStopTimer (index:int):void {			if (_timers[index]) {				_timers[index] = false;								dispatchEvent(new CustomVideoEvent(CustomVideoEvent.VIDEO_VIEW_TIMER_STOP, new VideoEventData(id, currentController.getReportingIdentifier(), index)));			}		}		private function addAllStudioEventListeners ():void {						if (_hasAllStudioEventListeners) {				return;			}						//if (!currentController) return;						var events:Array = CustomVideoEvent.getAllStudioVideoEvents();			var i:int = events.length;			while (i--) {				currentController.addEventListener(					events[i], studioVideoEventsHandler);			}						// TODO Thinking if PLAYHEAD_MOVE should be removed to free some process			//currentController.removeEventListener(//				'playheadMove', studioVideoEventsHandler);			_hasAllStudioEventListeners = true;						trace('add all event listeners');		}				private function removeAllStudioEventListeners ():void {				if (!_hasAllStudioEventListeners) {				return;			}						if (!currentController) return;			var events:Array = CustomVideoEvent.getAllStudioVideoEvents();			var i:int = events.length;			while (i--) {				currentController.removeEventListener(					events[i], studioVideoEventsHandler);			}				_hasAllStudioEventListeners = false;		}				private function callOnBuffered (callback:Function):void {			if (!_buffered) {				_bufferCallbacks.push(callback);			} else {				callback();			}		}				private function callBufferedCallbacks ():void {			_buffered = true;			while (_bufferCallbacks.length) {				_bufferCallbacks.shift()();								if (!_buffered) break;			}		}				// ------------------------------ EVENT HANDLERS -----------------------------------				private function addedToStageHandler (e:Event):void {			removeEventListener(Event.ADDED_TO_STAGE, addedToStageHandler);			addEventListener(Event.REMOVED_FROM_STAGE, removedFromStageHandler);			_collection.push(this);			_currentVideo = this;		}				private function removedFromStageHandler (e:Event):void {			if (!autoDestroy) return;						removeEventListener(Event.ADDED_TO_STAGE, addedToStageHandler);			removeEventListener(Event.REMOVED_FROM_STAGE, removedFromStageHandler);						var index:int = _collection.indexOf(this);			if (index != -1)				_collection.splice(index, 1)[0];						destroy();			if (_currentVideo == this)				_currentVideo = null;		}				private function studioVideoEventsHandler (e:Object):void {			var data:VideoEventData = new VideoEventData(				id, 				e.target.getReportingIdentifier(), 				getCurrentVideoIndex(), 				e.target.getElapsed(), 				e.target.getDuration()			);						dispatchEvent(new CustomVideoEvent(e.type, data));						switch ( e.type ) {				/*case 'buffered':					_buffredIndexes[data.index] = true;					callBufferedCallbacks();					break;*/									case 'play':					dispatchStartTimer(data.index);					callBufferedCallbacks();					if (_timer) 						_timer.start();					break;									case 'pause':					cancelPreview();					dispatchStopTimer(data.index);					callBufferedCallbacks();					break;									case 'complete':					cancelPreview();					dispatchStopTimer(data.index);					callBufferedCallbacks();										if (getCurrentVideoIndex() >= getNumberOfVideoControllers() - 1) {						dispatchEvent(new CustomVideoEvent(CustomVideoEvent.COMPLETE_ALL, data));					} else {						if (_settings.autoAdvanceVideoOnComplete)							next();					}					break;				default:			}								}	}	}